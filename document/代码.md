1. 我后端提供的api使用context向下传值
2. api的实现分为2层,逻辑层(负责处理逻辑,并发,报错),数据库操作层(处理数据库的查询操作),第三层只有一些根据message情况进行文字处理的和接收前端信息的代码
3. 使用到了操作系统的守护进程思想,有几个进程专门定时操作数据库,负责提供特殊的实时功能
4. 关于错误的处理,所有的错误处理代码都在service包中,除了非常严重的错误会使用log.panic()直接中断运行
5. gorm的使用,写出    err = postdb.Model(&User{}).Where("openid = ?", openid).First(&user).Error
   而不是    err = postdb.Where("openid = ?", openid).First(&user).Error
6. 关于前后端通信的问题,如果出现了不在正常使用情况的问题,就返回400和error,如果在正常使用情况下的错误,则使用400和message,正常情况其实可以不返回任何值,或者单纯的200和需要的结构体
7. service对error的处理,返回message,message中有isSuccess和haveError,和result,对第一层返回的错误进行处理
8. 第三层中,首先对haveError进行处理,如果存在问题,就进行错误处理,包括打印logger,传递错误消息.随后处理是否成功
9. 错误的打印，最好在第二层打印，如果发生在第三层也可在第三层答应，这个东西求多不求少

----

- 在长期的代码实践中发现， 功能应该一个一个实现，最好的节奏是一个小时写一个功能，并且同时给出说明文档
- 如何解决错误问题，实际的开发时，总会有各种错误，即使在开发的时候测试，仍然会留下一些没办法解决的问题，这个时候就需要设计使用环境的错误解决办法，最有效的就是，所有意料之中的错误都返回给用户，并且告诉用户联系管理员，并且在返回给用户之前都应该打印一下，以便于当用户反馈的时候能知道哪里错了

规定 处理星期问题的时候一律0 为星期天， 1~6 为星期1到6